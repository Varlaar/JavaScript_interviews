***  ТЕОРИЯ ***

***Введение*** 

JavaScript является однопоточным языком программирования, следовательно,
он может выполнять только одну задачу за раз, потому что у него только один стек вызовов.

***Основные понятия***

Heap - это некий участок памяти, выделяемый, например, под хранение объектов. 

Call stack - это то место, куда по ходу работы программы попадают вызванные функции, после чего выполняются.
Порядок, в котором стек обрабатывает каждый вызов функции, соответствует принципу LIFO (последний пришел, первый ушел).

WebApi - это интерфейс, предоставляемый браузером. С помощью него мы можем взаимодействовать с DOM-деревом, устанавливать таймеры,
отслеживать клики по элементам, отправлять запросы и тд.

Task queue - очередь задач, в которую попадают микротаски и макротаски.

Microtask queue - это очеред микротасок, сюда также попадают функции, но в отличии от макро - микро таски будут выполняться до тех пор,
пока они есть в очереди, и перед макротасками им отдается приоритет.

Macrotask queue - это очередь макротасок, сюда попадают некоторые функции (по принципу FIFO), и если callstack пустой, то первая
из очереди будет помещена в callstack и доступна к выполнению. Далее как только callstack очистится, будет вызвана следующая и тд.

EventLoop - собственно сам механизм, который и определяет приоритеты, решает какую задачу куда направить и в какой момент времени.

***Как работает (на примере кода из index.js и ./assets/EventLoop.png)***

В данном примере у нас есть две синхронные задачи (console.log(1) и console.log(5)), таймаут (макрозадача) и есть еще промис (микрозадача).

Сперва console.log(1) попадет в Call stack и тк это синхронная функция, она сразу удалится из Call stack и вернет результат 1 в Output.

Затем функция SetTimeout попадет в Call stack и будет отправлена в очередь макрозадач посредством WebApi, при этом в стек попадет следующая
задача и выполнение программы продолжится.

Далее создается объект Promise с помощью ключевого слова new, в конструктор которого передается функция, содержащая внутри себя вызов console.log(3) и метод resolve().
После вызова конструктора объект Promise имеет состояние pending. Код внутри конструктора промисов синхронный, так что сразу же будет выполнен console.log(3)
и вернет результат 3 в Output, затем вызовется функция resolve(), передаст значение 4 в колбэк и сразу же удалится из стека, а последующая обработка внутри метода then(),
т.е. каллбэк (value) => console.log(value) уже попадет в очередь микрозадач и будет ожидать когда стек полностью очистится.
Функция (value) => console.log(value), переданная в метод then объекта Promise, будет выполнена асинхронно, после того, как текущая синхронная операция закончится.
Таким образом, она является колбэком асинхронного события и будет добавлена в очередь задач microtask, которая будет выполняться после выполнения текущих синхронных
операций, но перед выполнением console.log(2) внутри setTimeout из очереди обработки событий (macrotask queue).

Далее будет выполнен console.log(5), и мы получаем ситуацию, что у нас есть по одной задаче в очереди микро- и макрозадач. 

Что же будет выполнено сначала? Нужно запомнить, что приоритет всегда будет отдан очереди микрозадач, при этом, если из очереди макрозадач задачи
берутся по одной и дальше идет проверка пуст ли стек чтобы взять следующую, то очередь микрозадач будет выполняться до тех пор, пока не закончится.
Следовательно, сначала будет выведен console.log(4), а затем console.log(2).
